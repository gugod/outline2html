#!/usr/bin/perl

use strict;
use Getopt::Std;
use Encode qw/from_to/;

my %opts;

$opts{l} = 2;
getopts('f:t:cpl:',\%opts);

my @tree;
my $last_title;
my $last_content;
my $last_level;

my @whole_content = <>;
my %LOCALVAR = find_localvar(\@whole_content);
$opts{p} = 1 if $LOCALVAR{"document-multipage-mode"};

my $DEFAULT_CODING_SYSTEM = "big5";
$LOCALVAR{"buffer-file-coding-system"} ||= $DEFAULT_CODING_SYSTEM;
$LOCALVAR{"document-output-coding-system"} ||=
    $LOCALVAR{"buffer-file-coding-system"};

unless ($LOCALVAR{"document-output-coding-system"} eq
	$LOCALVAR{"buffer-file-coding-system"}) {
    foreach (@whole_content) {
	from_to($_,
		$LOCALVAR{"buffer-file-coding-system"},
		$LOCALVAR{"document-output-coding-system"});
    }
    foreach (keys %LOCALVAR) {
	from_to($LOCALVAR{"$_"},
		$LOCALVAR{"buffer-file-coding-system"},
		$LOCALVAR{"document-output-coding-system"});
    }
}

## Expend [include:blah.txt], non-recursively ##

$/ = undef;
foreach (@whole_content) {
    if(m/^\s*\[include:(.*)\]\s*$/) {
	open(INCF, "< $1") || die ("Failed to insert the content of \"$1\"");
 	$_ = <INCF>;
 	close(INCF);
    }
}
@whole_content=map{"$_\n"}split/\n/,join"",@whole_content;
###############################

foreach(@whole_content) {
    if (m/^(\*+)\s*(.+)$/) {
	push @tree,
	    { title   => $last_title,
	      content => $last_content,
	      level   => $last_level
	    };
	$last_level = length($1);
	$last_title = $2;
	$last_content = '';
    } else {
	$last_content .= $_;
    }
}
push @tree,
    { title   => $last_title,
      content => $last_content,
      level   => $last_level
 };

shift @tree; # the first one is empty.

my $doc_title = $opts{t} || $LOCALVAR{"document-title"} || $ARGV[0];
my $htmlcharset   = $LOCALVAR{"document-output-coding-system"};
my $htmlhead =qq{<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh">
<head>
  <link rel="stylesheet" href="style.css" type="text/css" />
  <meta http-equiv="content-type" content="text/html;charset=$htmlcharset" />
  <title>$doc_title</title>
</head>
<body>

<h1 id="header">$doc_title</h1>
};

# Generate Index.

my ($title,$before,$after,$close_last,$toc_string);
$last_level  = 1;

my $root_i = -1;
$toc_string  = "<div id='toc'>\n<h1>Table of Contents</h1>\n<ul class='ullevel1'>\n";
for my $i (0..$#tree) {
    $_ = @tree[$i];
    next if ($_->{level} > $opts{l});
    if ($_->{level} == 1) {
	$root_i++;
	if ($opts{p}) {
	    $title = "<a href='root-${root_i}.html' accesskey='$root_i'>$_->{title}</a>";
	} else {
	    $title = "<a href='#section_root_$i'>$_->{title}</a>";
	}
    } else {
	if ($opts{p}) {
	    $title = "<a href='root-${root_i}.html#section_$i'>$_->{title}</a>";
#	    $title = "<A HREF='root-${root_i}.$i.html'>$_->{title}</A>";
	} else {
	    $title = "<a href='#section_$i'>$_->{title}</a>";
	}
    }

    my $liclass = "class='lilevel" . $_->{level} . "'";
    my $ulclass = "class='ullevel" . $_->{level} . "'";
    my $ulid    = "id='ulrootsection${root_i}'" if($_->{level} == 2);
    $before = "<li ${liclass}>"; $after  = "</li>"; $close_last = '';
    if ($_->{level} > $last_level) {
	$before = "\n<ul $ulclass $ulid>\n<li ${liclass}>";
    } elsif ($_->{level} < $last_level) {
	$close_last = "</ul>" x ($last_level - $_->{level}) . "\n\n";
	$before  = "<li ${liclass}>";
    }

    my $this_title = "${close_last}${before}${title}${after}";

    $toc_string .= "${this_title}\n";

    $last_level = $_->{level};
}
$toc_string .= "</ul></div>\n\n";


# Generate a div foreach section

my @sections_content;
my $section_content;

$section_content = "<div id='sections'>\n";
for my $i (0..$#tree) {
    $_ = @tree[$i];
    if ($_->{level} == 1) {
	if ($i > 0) {
	    $section_content .= "</div> <!-- section_root or section_\$i-->\n";
	    $section_content .= "</div> <!-- sections -->\n" if $opts{p};
	    push @sections_content,$section_content;
	    $section_content = '';
	    $section_content = "<div id='sections'>\n" if $opts{p}
	}
	$section_content .=
	    "<a id='section_root_$i'></a><div class='section_root' >\n";
    } else {
	$section_content .= "<div class='section' id='section_$i'>\n";
    }
    $section_content .= "<h$_->{level}>$_->{title}</h$_->{level}>";
    $section_content .= gencontent($_->{content}) . "\n"
	if ($_->{content} =~ /[^\s]/);
    $section_content .= "</div>\n" unless($_->{level} == 1);
}
$section_content .= "</div> <!-- last section_root -->\n";
$section_content .= "</div> <!-- sections -->\n";
push @sections_content,$section_content;

my $footer = $opts{f} ||
    $LOCALVAR{"document-footer"} ||
    'This page is generated by outline2html';

my $htmlbutt;
if ($footer) {
    $htmlbutt = qq{
<p id="footer">$footer</p>
</body></html>\n};
} else {
    $htmlbutt = qq{</body></html>\n};
}

if ($opts{p}) {
    for my $i (0..$#sections_content) {
	$_ = $sections_content[$i];
	open(FH,">root-$i.html");
	print FH $htmlhead;
	if ($opts{c}) {
	    print FH "<style type='text/css'> ul#ulrootsection$i {display: block;}";
	    print FH " .ullevel2 {display: none;} </style>\n";
	} else {
	    print FH "<style type='text/css'>";
	    print FH " .ullevel2 {display: block;} </style>\n";
	}
	print FH $_;
	print FH $toc_string;
	print FH $htmlbutt;
	close(FH);
    }
} else {
    print $htmlhead;
    print $toc_string;
    print foreach(@sections_content);
    print $htmlbutt;
}


# Other subroutines

sub gencontent {
    my $content = shift;

   my @paragraphs = split(/\n\n\n*/,$content);

    # enum, list <ul>,<li>
    foreach (@paragraphs) {
	s/^\n+//s; s/\s+\n//s;

	# Escape html entitites, but not those in the [ ].
	# http://www.gugod.org/  => <a ...>http://www.gugod.org</a>
	my $urlpattern = '(?:http|https|ftp)://(?:[^/\[\]:]+)(?::\d+)?/[^\|\s\[\]\(\)\<\>]*';
	my $emailpattern= '(?:[\w\d\.-]+@[\w\d\.-]+)';

	use English;
	my @lines = split /\n/;
	my $prefixed = 0;
	foreach(@lines) {
	    if(/$urlpattern/) {
		my($pre,$post) = ($PREMATCH, $POSTMATCH);
		unless(($pre =~ /\[/ && $post =~ /\]/) ||
		       ($pre =~ /\(/ && $post =~ /\)/)) {
		    s{($urlpattern)}{[\1|\1]};
		}
	    } elsif (/$emailpattern/ ) {
		my($pre,$post) = ($PREMATCH, $POSTMATCH);
		unless($pre =~ /\[/ && $post =~ /\]/) {
		    s{($emailpattern)}{[link:\1,mailto:\1]};
		}
	    }
	}
	$_ = join("\n", @lines);

	# It could be considered as everyhing in a [ ] are left untouched.
	s{(?<!\[)\G([^\[\]]*?)&([^\[\]]*?)(?!\])}{\1&amp;\2}g;
	s{(?<!\[)\G([^\[\]]*?)<([^\[\]]*?)(?!\])}{\1&lt;\2}g;
	s{(?<!\[)\G([^\[\]]*?)>([^\[\]]*?)(?!\])}{\1&gt;\2}g;

	# Handle special instructions
	s{\[image:\s*(.+?)\s*\]}{<img src="\1">}ig;
	s{\[link:\s*(\S+?)\s*,\s*(.+?)\s*\]}{<a href="\2">\1</a>}ig;
	s{\[(${urlpattern})\|(.+?)\]}{<a href="\1">\2</a>}ig;
	s{([^\s]+?)\s*\((${urlpattern})\)}{<a href="\2">\1</a>}ig;

	# Else, Treat anything in [ ] untouched.
	s{\[(.+?)\]}{\1}g;

	@lines = split /\n/;
	my $prefixed = 0;
	foreach(@lines) {
	    $prefixed++ if(/^\s*[\-\.ox#@\+=]\s/);
	}

	if(($prefixed-1 == $#lines) && $#lines > 0) {
	    my $new_p;
	    foreach (@lines) {
		s{^\s*[\-\.ox#@\+=]\s(.+)$}{<li>\1</li>};
		$new_p .= "$_\n";
	    }
	    $_ = "<ul>\n${new_p}</ul>";
	}
    }

    $content = '';
    foreach (@paragraphs) {
 	if (m/^\s*</ && m/<\/.+>\s*$/) {
	    $content .= "\n$_\n";
	} else {
            $content .= "\n<p>$_</p>\n"
	}
    }

    return $content;
}

sub find_localvar {
    my $lines = shift;
    my @backup;
    my $i = -1;
    my $localvar_start = 0;
    my %lvar ;
    my $failed = 0;

    while(1) {
        $_ = pop @$lines;
        push @backup, $_;
        last if /\S/;
    }

    if (/^End:?$/) {
        while(1) {
            $_ = pop @$lines;
            push @backup, $_;
            last if /^Local Variables:$/i;
            if(/:/) {
                    my ($var,$val) = split /:/,$_,2 ;
		    chomp($val);
		    $val =~ s/\s*\n//s;
		    $val =~ s/^\s+//s;
                    $lvar{"$var"} = $val;
            } else {
                $failed=1;
                last;
            }
        }
    } else {
        $failed = 1;
    }

    if($failed) {
        foreach (@backup) { push @$lines,$_; }
        undef %lvar;
    }
    return %lvar;
}


__END__

=head1 NAME

outline2html.pl - Convert Emacs outline-mode text into html pages.

=head1 SYNOPSIS

outline2html.pl S<[ B<-l> [I<level>] ]> foo.txt > foo.html

outline2html.pl S<[-p]> S<[B<-l> [I<level>] ]> foo.txt

=head1 OPTIONS

 -c	Collapse indexes. Expend it only when necessary.
 -l	Levels to expand in Table of content. Default to 2

 -p	Multi-page mode.
        (local var: document-multipage-mode)

 -t	Title of this document.
        (local var: document-title)

 -f	A constant footer on each page
        (local var: document-footer)

=head1 DESCRIPTION

This script is quite convienent for a Emacs outline-mode user who
wants to make html pages quickly. It generates html pages in two
styles: all nodes in a single page or a page for each root nodes.

HTML pages are generate in a structured fashion with default CSS
stylesheet named B<style.css>. It is also possible to embed links and
images , using the following format in your outline-mode text file:

  [image: picure.jpg]
  [link: link_title , path/to/some/where/]
  [http://url.of.some/where/|link_title]
  ... link_title (http://url.of.some/where/) ...

The first one makes a <IMG SRC="picture.jpg"> tag, where both of the
second and the third make a
<A HREF="http://url.of.some/where/">link_title</A> tag.
Notice that ONLY the [link: ...] style is capable to accpet relative
url.

You may also simply write an URL or email address _in one line_ ,
it will automatically create a hyperlink for it. For example:

    http://foo.org/  => <a href="http://foo.org/">http://foo.org/</a>
   <bar@no.com>      => &gt;<a href="mailto:bar@no.com">bar@no.com</a>&gt;

PLEASE NOTICE YOU HAVE TO PUT A TRAILING / IF YOUR URL IS NOT ENDED
WITH SOME FILENAME. http://foo.org won't work.

Paragraphs are seperated by a blank line in outline text file, and
will be convert to a <P>...</P> in html file. Enumerations could be
done by this simple way:

   - the item 1
   - the item 2
   - the item 3 , this should be enough for an example

You don't have to use the prefix '-' , just put the same string
before each line.

   . the item 1
   . the item 2
   . the item 3 , this should be enough for an example

A paragraph contain only lines like this will be convert to a <UL>.
(Un-numbered list). List prefix uses this regexp: [\-\.ox\*#@\+=]

Don't make an item too long. Currently it doesn't support something
look like this:

   . the item 1
   . the item 2 , this line is veryvery long such that you may
     want to break it into two lines in your text.
   . the item 3

Each root-i.html has accesskey i. You can press Alt-0 to quickly
access to root-0.html

The generated is tend to pass the XHTML 1.1 strict doctype validation.
Please send me some bug report in case you're generate pages are
not valid.

Besides command line arguments, you may also use the Emacs style per
buffer local variables to assign document's title, footer.  Simply put
an extra paragraph like the following to the end of your document:

  Local Variables:
  document-multipage-mode: t
  document-title: This is my document.
  document-footer: This page is generated by outline2html
  End:

Preceding whitespaces ARE NOT ALLOWED, but this would be modified in
the future to approach Emacs-way more. Case is senstive, please
donnot stuck you CAPSLOCK, ELSE IT WON'T WORK wELL. Command line
arguments would be used first if also assigned.

You may also generated new page to utf8 while wrting outline in your
familliar codying system, just put these two lines into your Local
Variable section:

  document-output-coding-system: utf-8
  buffer-file-coding-system: big5

It means to convert from big5 to utf-8. Please take a notice here that
the buffer-file-coding-system variable is also known by Emacs, and
Emacs would take this coding system to decode this file. Specifiying
inproper values here may cause errors in Emacs. The default value of any 
coding system variable is BIG5.

If you don't want to let outline2html to interpret some part in your text,
you could pack them in [ ], but not more then a line. It's a little
trick to embed any html code. For Example:

  [<h2>foobar</h2>]     =>   <h2>foobar</h2>
  [[<h2>foobar</h2>]]   =>   [<h2>foobar</h2>]
  [http://foo.org/]      =>   http://foo.org/

If you have many piece of outline and you want to combine them all in
one, you may use the [include:<filename>] special command to do so.
The expended document would be as if the content of <filename> is
inserted directly. However the last LocalVar section cannot be put
into a seperate file and then include. Also notice that this
includtion is non-recursive.

The latest relase information would be available on

  <http://www.gugod.org/outline2html/>

=head1 KNOWN BUGS

If you have a unordered list at the final paragraph of your text, the
last item goes into a new paragraph.

The [ ] verbatim scheme may be incomplete, randomly whitespaces may
eats your hyperlink. And it CANNOT CROSS LINES. A pair of [ ] for
verbatim purpose in different lines has no effect. And therefore
may cause unexpected output.

=head1 Copyright

Copyright 2003 by Kang-min Liu <gugod@gugod.org>.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

See <http://www.perl.com/perl/misc/Artistic.html>


